import logging
import os
import asyncio
import re
import aiohttp
import random
from aiogram import Bot, Dispatcher, types
from aiogram.filters import Command
import google.generativeai as genai

# –ü–æ–ª—É—á–∞–µ–º —Ç–æ–∫–µ–Ω—ã –∏–∑ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã—Ö –æ–∫—Ä—É–∂–µ–Ω–∏—è
TELEGRAM_BOT_TOKEN = os.getenv('TELEGRAM_BOT_TOKEN')
GEMINI_API_KEY = os.getenv('GEMINI_API_KEY')

# –ù–∞—Å—Ç—Ä–æ–π–∫–∞ Gemini API
genai.configure(api_key=GEMINI_API_KEY)
model = genai.GenerativeModel("gemini-1.5-pro-latest")

# –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –±–æ—Ç–∞ –∏ –¥–∏—Å–ø–µ—Ç—á–µ—Ä–∞
from aiogram.client.default import DefaultBotProperties
bot = Bot(token=TELEGRAM_BOT_TOKEN, default=DefaultBotProperties(parse_mode="MarkdownV2"))
dp = Dispatcher()
logging.basicConfig(level=logging.INFO)

# –•—Ä–∞–Ω–∏–ª–∏—â–µ –∏–º—ë–Ω –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π
user_names = {}

# –§—É–Ω–∫—Ü–∏—è –¥–ª—è —Ñ–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏—è –æ—Ç–≤–µ—Ç–∞
def format_gemini_response(text: str) -> str:
    special_chars = r"_[]()~>#+-=|{}.!"
    for ch in special_chars:
        text = text.replace(ch, f"\\{ch}")
    text = text.replace("**", "")
    text = re.sub(r'\s*```\w*\n', '```\n', text)
    text = re.sub(r'\n```\s*', '\n```', text)
    text = re.sub(r'```(\w+)?\n(.*?)\n```', lambda m: f"```\n{m.group(2)}\n```", text, flags=re.DOTALL)
    text = re.sub(r'(\d+\.) ', r'\n\1 ', text)
    return text

# –§—É–Ω–∫—Ü–∏—è –ø—Ä–æ–≤–µ—Ä–∫–∏ —É–ø–æ–º–∏–Ω–∞–Ω–∏—è –±–æ—Ç–∞
def is_bot_mentioned(message: types.Message):
    triggers = ["vai", "–≤–∞–π", "VAI", "Vai", "–í–∞–π"]
    text = message.text.lower()
    return any(trigger in text for trigger in triggers) or (message.reply_to_message and message.reply_to_message.from_user.id == bot.id)

# –§—É–Ω–∫—Ü–∏—è –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏ —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è —Å –∏–Ω—Ç–µ—Ä–Ω–µ—Ç–æ–º
async def check_internet():
    try:
        async with aiohttp.ClientSession() as session:
            async with session.get("https://www.google.com", timeout=5) as resp:
                return resp.status == 200
    except Exception:
        return False

# –§—É–Ω–∫—Ü–∏—è –¥–ª—è –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏—è –≤–æ–ø—Ä–æ—Å–æ–≤ –æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ
def is_user_name_question(text: str) -> bool:
    name_keywords = ["–∫–∞–∫ –º–µ–Ω—è –∑–æ–≤—É—Ç", "—Ç—ã –∑–Ω–∞–µ—à—å –º–æ–µ –∏–º—è", "—Ç—ã –ø–æ–º–Ω–∏—à—å –∫—Ç–æ —è"]
    return any(re.search(rf"\\b{re.escape(keyword)}\\b", text.lower()) for keyword in name_keywords)

# –§—É–Ω–∫—Ü–∏—è –∑–∞–ø–æ–º–∏–Ω–∞–Ω–∏—è –∏–º–µ–Ω–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
def remember_user_name(user_id: int, user_name: str):
    user_names[user_id] = user_name

# –ö–æ–º–∞–Ω–¥–∞ /start
@dp.message(Command("start"))
async def start_handler(message: types.Message):
    logging.info(f"–ö–æ–º–∞–Ω–¥–∞ /start –æ—Ç {message.from_user.id}")
    text = f"–ü—Ä–∏–≤–µ—Ç, {message.from_user.full_name}! ü§ñ –Ø AI –æ—Ç Vandili. –°–ø—Ä–∞—à–∏–≤–∞–π —á—Ç–æ —É–≥–æ–¥–Ω–æ!"
    remember_user_name(message.from_user.id, message.from_user.full_name)
    await message.answer(format_gemini_response(text), parse_mode="MarkdownV2")

# –û–±—Ä–∞–±–æ—Ç—á–∏–∫ –≤–æ–ø—Ä–æ—Å–æ–≤ –æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ
@dp.message()
async def handle_user_name_question(message: types.Message):
    user_id = message.from_user.id
    if is_user_name_question(message.text):
        if user_id in user_names:
            await message.answer(f"–¢—ã {user_names[user_id]}, –∫–∞–∫ –∂–µ —è –º–æ–≥ –∑–∞–±—ã—Ç—å? üòä", parse_mode="MarkdownV2")
        else:
            await message.answer("–Ø –ø–æ–∫–∞ –Ω–µ –∑–Ω–∞—é, –∫–∞–∫ —Ç–µ–±—è –∑–æ–≤—É—Ç. –ú–æ–∂–µ—à—å —Å–∫–∞–∑–∞—Ç—å –º–Ω–µ —Å–≤–æ—ë –∏–º—è?", parse_mode="MarkdownV2")
        return
    await chat_with_gemini(message)

# –û–±—Ä–∞–±–æ—Ç—á–∏–∫ —Å–æ–æ–±—â–µ–Ω–∏–π –≤ —á–∞—Ç —Å Gemini
@dp.message()
async def chat_with_gemini(message: types.Message):
    logging.info(f"–ü–æ–ª—É—á–µ–Ω–æ —Å–æ–æ–±—â–µ–Ω–∏–µ: {message.text} –æ—Ç {message.from_user.id}")
    if message.chat.type != 'private' and not is_bot_mentioned(message):
        return
    user_text = message.text
    for trigger in ["vai", "–≤–∞–π", "VAI", "Vai", "–í–∞–π"]:
        user_text = user_text.replace(trigger, "").strip()
    await bot.send_chat_action(message.chat.id, "typing")
    try:
        if not await check_internet():
            raise ConnectionError("–ù–µ—Ç –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è –∫ –∏–Ω—Ç–µ—Ä–Ω–µ—Ç—É")
        response = model.generate_content(user_text).text
        formatted_response = format_gemini_response(response)
        await message.answer(formatted_response, parse_mode="MarkdownV2")
    except aiohttp.ClientConnectionError:
        await message.answer("üö´ –û—à–∏–±–∫–∞: –ù–µ —É–¥–∞—ë—Ç—Å—è –ø–æ–¥–∫–ª—é—á–∏—Ç—å—Å—è –∫ –æ–±–ª–∞–∫–∞–º Vandili.", parse_mode="MarkdownV2")
    except ConnectionError:
        await message.answer("‚ö†Ô∏è –û—à–∏–±–∫–∞: –ù–µ—Ç –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è –∫ –∏–Ω—Ç–µ—Ä–Ω–µ—Ç—É. –ü—Ä–æ–≤–µ—Ä—å—Ç–µ —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–µ –∏ –ø–æ–ø—Ä–æ–±—É–π—Ç–µ —Å–Ω–æ–≤–∞.", parse_mode="MarkdownV2")
    except Exception as e:
        logging.error(f"–û—à–∏–±–∫–∞ –∑–∞–ø—Ä–æ—Å–∞: {e}")
        await message.answer(f"‚ùå –û—à–∏–±–∫–∞ –∑–∞–ø—Ä–æ—Å–∞: {format_gemini_response(str(e))}", parse_mode="MarkdownV2")

# –ó–∞–ø—É—Å–∫
async def main():
    logging.info("–ë–æ—Ç –∑–∞–ø—É—â–µ–Ω")
    await dp.start_polling(bot)

if __name__ == "__main__":
    asyncio.run(main())
