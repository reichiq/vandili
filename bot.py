# ---------------------- –ò–º–ø–æ—Ä—Ç—ã ---------------------- #
import logging
import os
import re
import random
import aiohttp
from io import BytesIO
from aiogram import Bot, Dispatcher, F
from aiogram.enums import ParseMode, ChatType
from aiogram.types import (
    FSInputFile, Message, InlineKeyboardMarkup, InlineKeyboardButton,
    CallbackQuery, InputFile, BufferedInputFile
)
from aiogram.client.default import DefaultBotProperties
from html import escape
from dotenv import load_dotenv
from pathlib import Path
import asyncio
import google.generativeai as genai
import tempfile
from aiogram.filters import Command
from pymorphy3 import MorphAnalyzer
from string import punctuation

from google.cloud import translate
from google.oauth2 import service_account

from docx import Document
from PyPDF2 import PdfReader
import json

# –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–µ –∏–º–ø–æ—Ä—Ç—ã –¥–ª—è –≥–æ–ª–æ—Å–æ–≤–æ–π –æ–±—Ä–∞–±–æ—Ç–∫–∏
from pydub import AudioSegment
import speech_recognition as sr
from gtts import gTTS

# ---------------------- –í—Å–ø–æ–º–æ–≥–∞—Ç–µ–ª—å–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è –¥–ª—è —á—Ç–µ–Ω–∏—è —Ñ–∞–π–ª–æ–≤ ---------------------- #
def extract_text_from_file(filename: str, file_bytes: bytes) -> str:
    if filename.endswith(".txt") or filename.endswith(".py"):
        return file_bytes.decode("utf-8", errors="ignore")
    elif filename.endswith(".pdf"):
        try:
            with BytesIO(file_bytes) as pdf_stream:
                reader = PdfReader(pdf_stream)
                return "\n".join(page.extract_text() or "" for page in reader.pages)
        except Exception:
            return ""
    elif filename.endswith(".docx"):
        try:
            with tempfile.NamedTemporaryFile(delete=False, suffix=".docx") as tmpf:
                tmpf.write(file_bytes)
                tmp_path = tmpf.name
            doc = Document(tmp_path)
            os.remove(tmp_path)
            return "\n".join(p.text for p in doc.paragraphs)
        except Exception:
            return ""
    return ""

# ---------------------- –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è ---------------------- #
key_path = '/root/vandili/gcloud-key.json'
credentials = service_account.Credentials.from_service_account_file(key_path)
translate_client = translate.TranslationServiceClient(credentials=credentials)

load_dotenv(dotenv_path=Path(__file__).resolve().parent / ".env")

TOKEN = os.getenv("BOT_TOKEN")
GEMINI_API_KEY = os.getenv("GEMINI_API_KEY")
UNSPLASH_ACCESS_KEY = os.getenv("UNSPLASH_ACCESS_KEY")
BOT_USERNAME = os.getenv("BOT_USERNAME")

logging.basicConfig(level=logging.INFO)

bot = Bot(token=TOKEN, default=DefaultBotProperties(parse_mode=ParseMode.HTML))
dp = Dispatcher()
morph = MorphAnalyzer()

genai.configure(api_key=GEMINI_API_KEY)
model = genai.GenerativeModel(model_name="models/gemini-2.0-flash")

# ---------------------- –•—Ä–∞–Ω–∏–º –∏—Å—Ç–æ—Ä–∏—é –¥–∏–∞–ª–æ–≥–æ–≤ –∏ —Ñ–∞–π–ª—ã ---------------------- #
chat_history = {}
user_documents = {}

# ---------------------- –ü–æ–¥–¥–µ—Ä–∂–∫–∞ –∏ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ ---------------------- #
support_mode_users = set()
support_reply_map = {}  # {admin_msg_id: user_id}

# ---------------------- –†–∞–±–æ—Ç–∞ —Å –æ—Ç–∫–ª—é—á—ë–Ω–Ω—ã–º–∏ —á–∞—Ç–∞–º–∏ ---------------------- #
DISABLED_CHATS_FILE = "disabled_chats.json"

def load_disabled_chats() -> set:
    if not os.path.exists(DISABLED_CHATS_FILE):
        return set()
    try:
        with open(DISABLED_CHATS_FILE, "r", encoding="utf-8") as f:
            data = json.load(f)
            return set(data)
    except Exception as e:
        logging.warning(f"[BOT] –ù–µ —É–¥–∞–ª–æ—Å—å –∑–∞–≥—Ä—É–∑–∏—Ç—å disabled_chats: {e}")
        return set()

def save_disabled_chats(chats: set):
    try:
        with open(DISABLED_CHATS_FILE, "w", encoding="utf-8") as f:
            json.dump(list(chats), f)
    except Exception as e:
        logging.warning(f"[BOT] –ù–µ —É–¥–∞–ª–æ—Å—å —Å–æ—Ö—Ä–∞–Ω–∏—Ç—å disabled_chats: {e}")

disabled_chats = load_disabled_chats()

ADMIN_ID = 1936733487

SUPPORT_PROMPT_TEXT = (
    "–û—Ç–ø—Ä–∞–≤—å—Ç–µ –ª—é–±–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ (—Ç–µ–∫—Å—Ç, —Ñ–æ—Ç–æ, –≤–∏–¥–µ–æ, —Ñ–∞–π–ª—ã, –∞—É–¥–∏–æ, –≥–æ–ª–æ—Å–æ–≤—ã–µ) ‚Äî –≤—Å—ë –¥–æ–π–¥—ë—Ç –¥–æ –ø–æ–¥–¥–µ—Ä–∂–∫–∏.\n\n"
    "–¢–∞–∫–∂–µ –≤—ã –º–æ–∂–µ—Ç–µ –æ—Ç–ø—Ä–∞–≤–ª—è—Ç—å –≥–æ–ª–æ—Å–æ–≤—ã–µ —Å–æ–æ–±—â–µ–Ω–∏—è ‚Äì —è –æ—Ç–≤–µ—á—É –≥–æ–ª–æ—Å–æ–º!"
)

def thread_kwargs(message: Message) -> dict:
    """
    –ï—Å–ª–∏ —ç—Ç–æ —Å—É–ø–µ—Ä–≥—Ä—É–ø–ø–∞/–≥—Ä—É–ø–ø–∞ —Å —Ç–æ–ø–∏–∫–∞–º–∏, –≤–æ–∑–≤—Ä–∞—â–∞–µ–º —Å–ª–æ–≤–∞—Ä—å {"message_thread_id": ...}.
    """
    if (message.chat.type in [ChatType.GROUP, ChatType.SUPERGROUP]
            and message.message_thread_id is not None):
        return {"message_thread_id": message.message_thread_id}
    return {}

# ---------------------- –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ (–æ–ø—Ü–∏–æ–Ω–∞–ª—å–Ω–æ) ---------------------- #
stats = {
    "messages_total": 0,
    "unique_users": set(),
    "files_received": 0,
    "commands_used": {}
}

def _register_message_stats(message: Message):
    stats["messages_total"] += 1
    stats["unique_users"].add(message.from_user.id)
    if message.text and message.text.startswith('/'):
        cmd = message.text.split()[0]
        stats["commands_used"][cmd] = stats["commands_used"].get(cmd, 0) + 1

# ---------------------- –§—É–Ω–∫—Ü–∏—è –æ—Ç–ø—Ä–∞–≤–∫–∏ –æ—Ç–≤–µ—Ç–∞ –∞–¥–º–∏–Ω–∞ –æ–¥–Ω–∏–º —Å–æ–æ–±—â–µ–Ω–∏–µ–º ---------------------- #
async def send_admin_reply_as_single_message(admin_message: Message, user_id: int):
    """
    –û—Ç–ø—Ä–∞–≤–ª—è–µ—Ç –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é user_id –æ–¥–Ω–æ —Å–æ–æ–±—â–µ–Ω–∏–µ, —Å–æ–¥–µ—Ä–∂–∞—â–µ–µ:
    <b>–û—Ç–≤–µ—Ç –æ—Ç –ø–æ–¥–¥–µ—Ä–∂–∫–∏:</b> –∏ –∫–æ–Ω—Ç–µ–Ω—Ç –æ—Ç–≤–µ—Ç–∞ –∞–¥–º–∏–Ω–∞.
    –î–ª—è –º–µ–¥–∏–∞-—Å–æ–æ–±—â–µ–Ω–∏–π –ø—Ä–µ—Ñ–∏–∫—Å –¥–æ–±–∞–≤–ª—è–µ—Ç—Å—è –≤ caption.
    """
    prefix = "<b>–û—Ç–≤–µ—Ç –æ—Ç –ø–æ–¥–¥–µ—Ä–∂–∫–∏:</b>"
    if admin_message.text:
        reply_text = f"{prefix}\n{admin_message.text}"
        await bot.send_message(chat_id=user_id, text=reply_text)
    elif admin_message.photo:
        caption = prefix
        if admin_message.caption:
            caption += f"\n{admin_message.caption}"
        await bot.send_photo(chat_id=user_id, photo=admin_message.photo[-1].file_id, caption=caption)
    elif admin_message.voice:
        caption = prefix
        if admin_message.caption:
            caption += f"\n{admin_message.caption}"
        await bot.send_voice(chat_id=user_id, voice=admin_message.voice.file_id, caption=caption)
    elif admin_message.video:
        caption = prefix
        if admin_message.caption:
            caption += f"\n{admin_message.caption}"
        await bot.send_video(chat_id=user_id, video=admin_message.video.file_id, caption=caption)
    elif admin_message.document:
        caption = prefix
        if admin_message.caption:
            caption += f"\n{admin_message.caption}"
        await bot.send_document(chat_id=user_id, document=admin_message.document.file_id, caption=caption)
    elif admin_message.audio:
        caption = prefix
        if admin_message.caption:
            caption += f"\n{admin_message.caption}"
        await bot.send_audio(chat_id=user_id, audio=admin_message.audio.file_id, caption=caption)
    else:
        await bot.send_message(chat_id=user_id, text=f"{prefix}\n[–°–æ–æ–±—â–µ–Ω–∏–µ –≤ –Ω–µ–ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ–º–æ–º —Ñ–æ—Ä–º–∞—Ç–µ]")

# ---------------------- –û–±—Ä–∞–±–æ—Ç—á–∏–∫–∏ –∫–æ–º–∞–Ω–¥ ---------------------- #
@dp.message(Command("start"))
async def cmd_start(message: Message):
    """
    –í –õ–° ‚Äî –æ–±—ã—á–Ω—ã–π —Å—Ç–∞—Ä—Ç (—Å –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–µ–π –æ –≥–æ–ª–æ—Å–æ–≤–æ–π –ø–æ–¥–¥–µ—Ä–∂–∫–µ).
    –í –≥—Ä—É–ø–ø–µ/—Å—É–ø–µ—Ä–≥—Ä—É–ø–ø–µ ‚Äî —Å–Ω–∏–º–∞–µ–º –æ—Ç–∫–ª—é—á–µ–Ω–∏–µ (—É–¥–∞–ª—è–µ–º chat.id –∏–∑ disabled_chats).
    """
    _register_message_stats(message)
    if message.chat.type == ChatType.PRIVATE and message.text.startswith("/start support"):
        support_mode_users.add(message.from_user.id)
        await message.answer(SUPPORT_PROMPT_TEXT)
        return
    if message.chat.type in [ChatType.GROUP, ChatType.SUPERGROUP]:
        if message.chat.id in disabled_chats:
            disabled_chats.remove(message.chat.id)
            save_disabled_chats(disabled_chats)
            await message.answer("–ë–æ—Ç —Å–Ω–æ–≤–∞ –≤–∫–ª—é—á—ë–Ω –≤ —ç—Ç–æ–º —á–∞—Ç–µ.", **thread_kwargs(message))
            logging.info(f"[BOT] –ë–æ—Ç —Å–Ω–æ–≤–∞ –≤–∫–ª—é—á—ë–Ω –≤ –≥—Ä—É–ø–ø–µ {message.chat.id}")
        else:
            await message.answer("–ë–æ—Ç —É–∂–µ –∞–∫—Ç–∏–≤–µ–Ω –≤ —ç—Ç–æ–º —á–∞—Ç–µ.", **thread_kwargs(message))
        return
    greet = """–ü—Ä–∏–≤–µ—Ç! –Ø <b>VAI</b> ‚Äî –∏–Ω—Ç–µ–ª–ª–µ–∫—Ç—É–∞–ª—å–Ω—ã–π –ø–æ–º–æ—â–Ω–∏–∫ üòä

–í–æ—Ç —á—Ç–æ —è —É–º–µ—é:
‚Ä¢ –ß–∏—Ç–∞—é PDF, DOCX, TXT –∏ .py-—Ñ–∞–π–ª—ã ‚Äî –ø—Ä–æ—Å—Ç–æ –æ—Ç–ø—Ä–∞–≤—å –º–Ω–µ —Ñ–∞–π–ª.
‚Ä¢ –û—Ç–≤–µ—á–∞—é –Ω–∞ –≤–æ–ø—Ä–æ—Å—ã –ø–æ —Å–æ–¥–µ—Ä–∂–∏–º–æ–º—É —Ñ–∞–π–ª–∞.
‚Ä¢ –ü–æ–º–æ–≥–∞—é —Å –∫–æ–¥–æ–º ‚Äî –Ω–∞–ø–∏—à–∏ #—Ä–µ—Ñ–∞–∫—Ç–æ—Ä –∏ –≤—Å—Ç–∞–≤—å –∫–æ–¥.
‚Ä¢ –ü–æ–∫–∞–∑—ã–≤–∞—é –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è –ø–æ –∫–ª—é—á–µ–≤—ã–º —Å–ª–æ–≤–∞–º.
‚Ä¢ –ü–æ–¥–¥–µ—Ä–∂–∏–≤–∞—é –∫–æ–º–∞–Ω–¥—ã /help –∏ —Ä–µ–∂–∏–º –ø–æ–¥–¥–µ—Ä–∂–∫–∏.
‚Ä¢ –¢–µ–ø–µ—Ä—å –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞—é –≥–æ–ª–æ—Å–æ–≤—ã–µ —Å–æ–æ–±—â–µ–Ω–∏—è ‚Äì –æ—Ç–ø—Ä–∞–≤–ª—è–π—Ç–µ –≥–æ–ª–æ—Å, –∞ —è –æ—Ç–≤–µ—á—É –≥–æ–ª–æ—Å–æ–º!

–í—Å–µ–≥–¥–∞ –Ω–∞ —Å–≤—è–∑–∏!"""
    await bot.send_message(chat_id=message.chat.id, text=greet, **thread_kwargs(message))

@dp.message(Command("stop"))
async def cmd_stop(message: Message):
    """
    –í –≥—Ä—É–ø–ø–µ/—Å—É–ø–µ—Ä–≥—Ä—É–ø–ø–µ ‚Äî –¥–æ–±–∞–≤–ª—è–µ–º —á–∞—Ç –≤ disabled_chats, –æ—Ç–∫–ª—é—á–∞—è –±–æ—Ç–∞.
    """
    _register_message_stats(message)
    if message.chat.type in [ChatType.GROUP, ChatType.SUPERGROUP]:
        disabled_chats.add(message.chat.id)
        save_disabled_chats(disabled_chats)
        await bot.send_message(chat_id=message.chat.id, text="–ë–æ—Ç –æ—Ç–∫–ª—é—á—ë–Ω –≤ —ç—Ç–æ–º —á–∞—Ç–µ.", **thread_kwargs(message))
        logging.info(f"[BOT] –ë–æ—Ç –æ—Ç–∫–ª—é—á—ë–Ω –≤ –≥—Ä—É–ø–ø–µ {message.chat.id}")
    else:
        await message.answer("–ö–æ–º–∞–Ω–¥–∞ /stop —Ä–∞–±–æ—Ç–∞–µ—Ç —Ç–æ–ª—å–∫–æ –≤ –≥—Ä—É–ø–ø–µ.")

@dp.message(Command("help"))
async def cmd_help(message: Message):
    _register_message_stats(message)
    if message.chat.type == ChatType.PRIVATE:
        keyboard = InlineKeyboardMarkup(
            inline_keyboard=[[InlineKeyboardButton(text="‚úâÔ∏è –ù–∞–ø–∏—Å–∞—Ç—å –≤ –ø–æ–¥–¥–µ—Ä–∂–∫—É", callback_data="support_request")]]
        )
        await bot.send_message(chat_id=message.chat.id, text="–ï—Å–ª–∏ –≤–æ–∑–Ω–∏–∫ –≤–æ–ø—Ä–æ—Å –∏–ª–∏ —Ö–æ—á–µ—à—å —Å–æ–æ–±—â–∏—Ç—å –æ–± –æ—à–∏–±–∫–µ ‚Äî –Ω–∞–ø–∏—à–∏ –Ω–∞–º:", reply_markup=keyboard)
    else:
        private_url = f"https://t.me/{BOT_USERNAME}?start=support"
        keyboard = InlineKeyboardMarkup(
            inline_keyboard=[[InlineKeyboardButton(text="‚úâÔ∏è –ù–∞–ø–∏—Å–∞—Ç—å –≤ –ø–æ–¥–¥–µ—Ä–∂–∫—É", url=private_url)]]
        )
        await bot.send_message(chat_id=message.chat.id, text="–ï—Å–ª–∏ –≤–æ–∑–Ω–∏–∫ –≤–æ–ø—Ä–æ—Å –∏–ª–∏ —Ö–æ—á–µ—à—å —Å–æ–æ–±—â–∏—Ç—å –æ–± –æ—à–∏–±–∫–µ ‚Äî –Ω–∞–ø–∏—à–∏ –º–Ω–µ –≤ –ª–∏—á–∫—É:", reply_markup=keyboard, **thread_kwargs(message))

@dp.message(Command("adminstats"))
async def cmd_adminstats(message: Message):
    _register_message_stats(message)
    if message.from_user.id != ADMIN_ID:
        return
    total_msgs = stats["messages_total"]
    unique_users_count = len(stats["unique_users"])
    files_received = stats["files_received"]
    cmd_usage = stats["commands_used"]
    if not cmd_usage:
        top_commands = []
    else:
        top_commands = sorted(cmd_usage.items(), key=lambda x: x[1], reverse=True)[:3]
    text = (
        f"üìä <b>–°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –±–æ—Ç–∞</b>\n\n"
        f"–í—Å–µ–≥–æ —Å–æ–æ–±—â–µ–Ω–∏–π: {total_msgs}\n"
        f"–£–Ω–∏–∫–∞–ª—å–Ω—ã—Ö –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π: {unique_users_count}\n"
        f"–ü–æ–ª—É—á–µ–Ω–æ —Ñ–∞–π–ª–æ–≤: {files_received}\n\n"
    )
    if top_commands:
        text += "–¢–æ–ø –∫–æ–º–∞–Ω–¥:\n"
        for cmd, cnt in top_commands:
            text += f"  {cmd}: {cnt}\n"
    else:
        text += "–ö–æ–º–∞–Ω–¥—ã –µ—â—ë –Ω–µ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–ª–∏—Å—å."
    await message.answer(text)

# ---------------------- –†–µ–∂–∏–º –ø–æ–¥–¥–µ—Ä–∂–∫–∏ (callback) ---------------------- #
@dp.callback_query(F.data == "support_request")
async def handle_support_click(callback: CallbackQuery):
    await callback.answer()
    support_mode_users.add(callback.from_user.id)
    await callback.message.answer(SUPPORT_PROMPT_TEXT)

# ---------------------- –û–±—Ä–∞–±–æ—Ç–∫–∞ –≥–æ–ª–æ—Å–æ–≤—ã—Ö —Å–æ–æ–±—â–µ–Ω–∏–π –æ—Ç –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π ---------------------- #
# –û–±—Ä–∞–±–æ—Ç–∫–∞ –≥–æ–ª–æ—Å–æ–≤—ã—Ö —Å–æ–æ–±—â–µ–Ω–∏–π –≤—ã–ø–æ–ª–Ω—è–µ—Ç—Å—è —Ç–æ–ª—å–∫–æ –≤ –æ–±—ã—á–Ω–æ–º —á–∞—Ç–µ (–Ω–µ –≤ –ø–æ–¥–¥–µ—Ä–∂–∫–µ)
@dp.message()
async def handle_all_messages(message: Message):
    # 1. –ï—Å–ª–∏ –∞–¥–º–∏–Ω –æ—Ç–≤–µ—á–∞–µ—Ç —Ä–µ–ø–ª–∞–µ–º –≤ —Å–≤–æ—ë–º —á–∞—Ç–µ
    if message.chat.id == ADMIN_ID and message.reply_to_message:
        original_id = message.reply_to_message.message_id
        if original_id in support_reply_map:
            user_id = support_reply_map[original_id]
            try:
                await send_admin_reply_as_single_message(message, user_id)
            except Exception as e:
                logging.warning(f"[BOT] –û—à–∏–±–∫–∞ –ø—Ä–∏ –æ—Ç–ø—Ä–∞–≤–∫–µ –æ—Ç–≤–µ—Ç–∞ –∞–¥–º–∏–Ω–∞ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é: {e}")
        return

    _register_message_stats(message)
    uid = message.from_user.id
    cid = message.chat.id

    # 2. –ï—Å–ª–∏ —Å–æ–æ–±—â–µ–Ω–∏–µ ‚Äì –≥–æ–ª–æ—Å–æ–≤–æ–µ –æ—Ç –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è (–∏ –Ω–µ –æ—Ç –∞–¥–º–∏–Ω–∞)
    if message.voice and cid != ADMIN_ID:
        try:
            file_info = await bot.get_file(message.voice.file_id)
            voice_file_url = f"https://api.telegram.org/file/bot{TOKEN}/{file_info.file_path}"
            async with aiohttp.ClientSession() as session:
                async with session.get(voice_file_url) as resp:
                    voice_bytes = await resp.read()
            with tempfile.NamedTemporaryFile(delete=False, suffix=".ogg") as tmp_voice:
                tmp_voice.write(voice_bytes)
                ogg_path = tmp_voice.name
            # –ö–æ–Ω–≤–µ—Ä—Ç–∏—Ä—É–µ–º OGG –≤ WAV
            audio = AudioSegment.from_file(ogg_path, format="ogg")
            wav_path = ogg_path.replace(".ogg", ".wav")
            audio.export(wav_path, format="wav")
            recognizer = sr.Recognizer()
            with sr.AudioFile(wav_path) as source:
                audio_data = recognizer.record(source)
            try:
                text_from_voice = recognizer.recognize_sphinx(audio_data, language="ru-RU")
            except Exception as e:
                logging.warning(f"[BOT] –û—à–∏–±–∫–∞ —Ä–∞—Å–ø–æ–∑–Ω–∞–≤–∞–Ω–∏—è —Ä–µ—á–∏: {e}")
                text_from_voice = ""
            os.remove(ogg_path)
            os.remove(wav_path)
            if text_from_voice:
                # –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º –æ—Ç–≤–µ—Ç —á–µ—Ä–µ–∑ Gemini
                response_text = await generate_and_send_gemini_response(cid, text_from_voice, False, "", "")
                # –°–∏–Ω—Ç–µ–∑–∏—Ä—É–µ–º –≥–æ–ª–æ—Å–æ–≤–æ–π –æ—Ç–≤–µ—Ç —á–µ—Ä–µ–∑ gTTS
                tts = gTTS(response_text, lang="ru")
                with tempfile.NamedTemporaryFile(delete=False, suffix=".mp3") as tmp_tts:
                    tts.save(tmp_tts.name)
                    mp3_path = tmp_tts.name
                audio_tts = AudioSegment.from_mp3(mp3_path)
                ogg_tts_path = mp3_path.replace(".mp3", ".ogg")
                audio_tts.export(ogg_tts_path, format="ogg")
                os.remove(mp3_path)
                caption = "<b>–û—Ç–≤–µ—Ç –æ—Ç –ø–æ–¥–¥–µ—Ä–∂–∫–∏:</b>"
                await bot.send_voice(chat_id=cid, voice=InputFile(ogg_tts_path), caption=caption)
                os.remove(ogg_tts_path)
            else:
                await bot.send_message(chat_id=cid, text="–ù–µ —É–¥–∞–ª–æ—Å—å —Ä–∞—Å–ø–æ–∑–Ω–∞—Ç—å –≥–æ–ª–æ—Å–æ–≤–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ.")
        except Exception as e:
            logging.error(f"[BOT] –û—à–∏–±–∫–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∏ –≥–æ–ª–æ—Å–æ–≤–æ–≥–æ —Å–æ–æ–±—â–µ–Ω–∏—è: {e}")
            await bot.send_message(chat_id=cid, text="–û—à–∏–±–∫–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∏ –≥–æ–ª–æ—Å–æ–≤–æ–≥–æ —Å–æ–æ–±—â–µ–Ω–∏—è.")
        return

    # 3. –ï—Å–ª–∏ —Å–æ–æ–±—â–µ–Ω–∏–µ –∏–∑ –≥—Ä—É–ø–ø—ã/—Å—É–ø–µ—Ä–≥—Ä—É–ø–ø—ã –∏ —á–∞—Ç –æ—Ç–∫–ª—é—á—ë–Ω ‚Äî –∏–≥–Ω–æ—Ä–∏—Ä—É–µ–º
    if message.chat.type in [ChatType.GROUP, ChatType.SUPERGROUP]:
        if cid in disabled_chats:
            return

    # 4. –ï—Å–ª–∏ —Å–æ–æ–±—â–µ–Ω–∏–µ —Å–æ–¥–µ—Ä–∂–∏—Ç –¥–æ–∫—É–º–µ–Ω—Ç (—Ñ–∞–π–ª)
    if message.document:
        stats["files_received"] += 1
        file = await bot.get_file(message.document.file_id)
        url = f"https://api.telegram.org/file/bot{TOKEN}/{file.file_path}"
        async with aiohttp.ClientSession() as session:
            async with session.get(url) as resp:
                file_bytes = await resp.read()
        text = extract_text_from_file(message.document.file_name, file_bytes)
        if text:
            user_documents[uid] = text
            await message.answer("‚úÖ –§–∞–π–ª –ø–æ–ª—É—á–µ–Ω! –ú–æ–∂–µ—à—å –∑–∞–¥–∞—Ç—å –≤–æ–ø—Ä–æ—Å –ø–æ –µ–≥–æ —Å–æ–¥–µ—Ä–∂–∏–º–æ–º—É.")
        else:
            await message.answer("‚ö†Ô∏è –ù–µ —É–¥–∞–ª–æ—Å—å –∏–∑–≤–ª–µ—á—å —Ç–µ–∫—Å—Ç –∏–∑ —Ñ–∞–π–ª–∞.")
        return

    logging.info(f"[DEBUG] Message from {uid}: content_type={message.content_type}, has_document={bool(message.document)}, text={message.text!r}")
    await handle_msg(message)

# ---------------------- "–í–∞–π –ø–æ–∫–∞–∂–∏ ..." ---------------------- #
@dp.message(F.text.lower().startswith("–≤–∞–π –ø–æ–∫–∞–∂–∏"))
async def group_show_request(message: Message):
    await handle_msg(message)

# ---------------------- –õ–æ–≥–∏–∫–∞ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –æ—Ç–≤–µ—Ç–∞ Gemini ---------------------- #
async def generate_and_send_gemini_response(cid, full_prompt, show_image, rus_word, leftover):
    gemini_text = ""
    analysis_keywords = [
        "–ø–æ—á–µ–º—É", "–∑–∞—á–µ–º", "–Ω–∞ –∫–æ–≥–æ", "–∫—Ç–æ", "—á—Ç–æ —Ç–∞–∫–æ–µ", "–≤–ª–∏—è–Ω–∏–µ",
        "—Ñ–∏–ª–æ—Å–æ—Ñ", "–æ—Ç—Ä–∏—Ü–∞–ª", "–ø–æ–≤–ª–∏—è–ª", "—Å–º—ã—Å–ª", "—ç–∫–∑–∏—Å—Ç–µ–Ω—Ü–∏–∞–ª–∏–∑–º", "–æ–ø—Ä–æ–≤–µ—Ä–≥"
    ]
    needs_expansion = any(k in full_prompt.lower() for k in analysis_keywords)
    if needs_expansion:
        smart_prompt = (
            "–û—Ç–≤–µ—Ç—å —á—ë—Ç–∫–æ –∏ –ø–æ –¥–µ–ª—É. –ï—Å–ª–∏ –≤ –≤–æ–ø—Ä–æ—Å–µ –Ω–µ—Å–∫–æ–ª—å–∫–æ —á–∞—Å—Ç–µ–π ‚Äî –æ—Ç–≤–µ—Ç—å –Ω–∞ –∫–∞–∂–¥—É—é. "
            "–ü—Ä–∏–≤–æ–¥–∏ –∏–º–µ–Ω–∞ –∏ –∫–æ–Ω–∫—Ä–µ—Ç–Ω—ã–µ –ø—Ä–∏–º–µ—Ä—ã, –µ—Å–ª–∏ –æ–Ω–∏ –µ—Å—Ç—å. –ù–µ –ø–æ–≤—Ç–æ—Ä—è–π –≤–æ–ø—Ä–æ—Å, –ø—Ä–æ—Å—Ç–æ –æ—Ç–≤–µ—Ç—å:\n\n"
        )
        full_prompt = smart_prompt + full_prompt
    if show_image and rus_word and not leftover:
        gemini_text = generate_short_caption(rus_word)
        return gemini_text
    conversation = chat_history.setdefault(cid, [])
    # –ò—Å–ø—Ä–∞–≤–ª–µ–Ω–æ: –∏—Å–ø–æ–ª—å–∑—É–µ–º "parts" –∫–∞–∫ –∏ –æ–∂–∏–¥–∞–ª–æ—Å—å
    conversation.append({"role": "user", "parts": [full_prompt]})
    if len(conversation) > 8:
        conversation.pop(0)
    try:
        await bot.send_chat_action(chat_id=cid, action="typing")
        resp = model.generate_content(conversation)
        if not resp.candidates:
            reason = getattr(resp.prompt_feedback, "block_reason", "–Ω–µ–∏–∑–≤–µ—Å—Ç–Ω–∞")
            logging.warning(f"[BOT] –ó–∞–ø—Ä–æ—Å –∑–∞–±–ª–æ–∫–∏—Ä–æ–≤–∞–Ω Gemini: –ø—Ä–∏—á–∏–Ω–∞ ‚Äî {reason}")
            gemini_text = ("‚ö†Ô∏è –ó–∞–ø—Ä–æ—Å –æ—Ç–∫–ª–æ–Ω—ë–Ω. –í–æ–∑–º–æ–∂–Ω–æ, –æ–Ω —Å–æ–¥–µ—Ä–∂–∏—Ç –Ω–µ–¥–æ–ø—É—Å—Ç–∏–º—ã–π –∏–ª–∏ —á—É–≤—Å—Ç–≤–∏—Ç–µ–ª—å–Ω—ã–π –∫–æ–Ω—Ç–µ–Ω—Ç.")
        else:
            raw_model_text = resp.text
            gemini_text = format_gemini_response(raw_model_text)
            conversation.append({"role": "assistant", "parts": [raw_model_text]})
            if len(conversation) > 8:
                conversation.pop(0)
    except Exception as e:
        logging.error(f"[BOT] –û—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±—Ä–∞—â–µ–Ω–∏–∏ –∫ Gemini: {e}")
        gemini_text = ("‚ö†Ô∏è –ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –æ—Ç–≤–µ—Ç–∞. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â—ë —Ä–∞–∑ –ø–æ–∑–∂–µ.")
    return gemini_text

CAPTION_LIMIT = 950
TELEGRAM_MSG_LIMIT = 4096

IMAGE_TRIGGERS_RU = ["–ø–æ–∫–∞–∂–∏", "–ø–æ–∫–∞–∂–∏ –º–Ω–µ", "—Ö–æ—á—É —É–≤–∏–¥–µ—Ç—å", "–ø—Ä–∏—à–ª–∏ —Ñ–æ—Ç–æ", "—Ñ–æ—Ç–æ"]

NAME_COMMANDS = [
    "–∫–∞–∫ —Ç–µ–±—è –∑–æ–≤—É—Ç", "—Ç–≤–æ–µ –∏–º—è", "—Ç–≤–æ—ë –∏–º—è", "what is your name", "who are you"
]
INFO_COMMANDS = [
    "–∫—Ç–æ —Ç–µ–±—è —Å–æ–∑–¥–∞–ª", "–∫—Ç–æ —Ç—ã", "–∫—Ç–æ —Ä–∞–∑—Ä–∞–±–æ—Ç—á–∏–∫", "–∫—Ç–æ —Ç–≤–æ–π –∞–≤—Ç–æ—Ä",
    "–∫—Ç–æ —Ç–≤–æ–π —Å–æ–∑–¥–∞—Ç–µ–ª—å", "—á–µ–π —Ç—ã –±–æ—Ç", "–∫–µ–º —Ç—ã –±—ã–ª —Å–æ–∑–¥–∞–Ω",
    "–∫—Ç–æ —Ö–æ–∑—è–∏–Ω", "–∫—Ç–æ —Ç–≤–æ–π –≤–ª–∞–¥–µ–ª–µ—Ü", "–≤ —Å–º—ã—Å–ª–µ –∫—Ç–æ —Ç–≤–æ–π —Å–æ–∑–¥–∞—Ç–µ–ª—å"
]

OWNER_REPLIES = [
    "–Ø ‚Äî <b>VAI</b>, —Å–æ–∑–¥–∞–Ω –∫–æ–º–∞–Ω–¥–æ–π <i>Vandili</i> üòé",
    "–ú–æ–π —Å–æ–∑–¥–∞—Ç–µ–ª—å ‚Äî <b>Vandili</b>. –Ø —Ä–∞–±–æ—Ç–∞—é –¥–ª—è –Ω–∏—Ö üòâ",
    "–Ø –ø—Ä–∏–Ω–∞–¥–ª–µ–∂—É <i>Vandili</i>, –æ–Ω–∏ –º–æ—è –∫–æ–º–∞–Ω–¥–∞ ‚ú®",
    "–°–æ–∑–¥–∞–Ω <b>Vandili</b> ‚Äî –∏–º–µ–Ω–Ω–æ –æ–Ω–∏ –¥–∞–ª–∏ –º–Ω–µ –∂–∏–∑–Ω—å ü§ù",
    "–Ø –±–æ—Ç <b>Vandili</b>. –í—Å—ë –ø—Ä–æ—Å—Ç–æ ü§ó",
    "–Ø –ø—Ä–æ–¥—É–∫—Ç <i>Vandili</i>. –û–Ω–∏ –º–æ–∏ —Å–æ–∑–¥–∞—Ç–µ–ª–∏ üòá"
]

RU_EN_DICT = {
    "–æ–±–µ–∑—å—è–Ω–∞": "monkey",
    "—Ç–∏–≥—Ä": "tiger",
    "–∫–æ—à–∫–∞": "cat",
    "—Å–æ–±–∞–∫–∞": "dog",
    "–ø–µ–π–∑–∞–∂": "landscape",
    "—á–∞–π–∫–∞": "seagull",
    "–ø–∞—Ä–∏–∂": "paris",
    "—É—Ç–∫–æ–Ω–æ—Å": "platypus",
    "–ø—É–¥–µ–ª—å": "poodle",
    "–º–µ–¥–æ–µ–¥": "honey badger"
}

def split_smart(text: str, limit: int) -> list[str]:
    results = []
    start = 0
    length = len(text)
    while start < length:
        remain = length - start
        if remain <= limit:
            results.append(text[start:].strip())
            break
        candidate = text[start: start+limit]
        cut_pos = candidate.rfind('. ')
        if cut_pos == -1:
            cut_pos = candidate.rfind(' ')
            if cut_pos == -1:
                cut_pos = len(candidate)
        else:
            cut_pos += 1
        chunk = text[start: start+cut_pos].strip()
        if chunk:
            results.append(chunk)
        start += cut_pos
    return [x for x in results if x]

def split_caption_and_text(text: str) -> tuple[str, list[str]]:
    if len(text) <= CAPTION_LIMIT:
        return text, []
    chunks_950 = split_smart(text, CAPTION_LIMIT)
    caption = chunks_950[0]
    leftover = " ".join(chunks_950[1:]).strip()
    if not leftover:
        return caption, []
    rest = split_smart(leftover, TELEGRAM_MSG_LIMIT)
    return caption, rest

# ---------------------- –ó–∞–ø—É—Å–∫ –±–æ—Ç–∞ ---------------------- #
async def main():
    await dp.start_polling(bot)

if __name__ == "__main__":
    asyncio.run(main())
